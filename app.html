<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>JekyllChess PGN App</title>

<!-- jQuery (required by your setup) -->
<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<!-- Chess libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
<link rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">

<style>
* { box-sizing: border-box; }
body{
  margin:0;
  background:#0f1115;
  color:#e6e6e6;
  font-family:system-ui,-apple-system,sans-serif;
}

.top{
  padding:10px 14px;
  background:#171a21;
  border-bottom:1px solid #222;
  display:flex;
  align-items:center;
  gap:10px;
}
.top img{ width:22px; height:22px; filter:invert(1); }
.top .title{ font-weight:700; }

.wrap{
  display:flex;
  flex-direction:column;
  gap:10px;
  padding:12px;
}

#board{
  width:min(92vw,560px);
  margin:0 auto;
}

.controls{
  width:min(92vw,560px);
  margin:0 auto;
  display:flex;
  gap:6px;
}
.controls button{
  flex:1;
  padding:10px 0;
  border:none;
  border-radius:10px;
  background:#1f2430;
  color:#ddd;
  font-size:15px;
  cursor:pointer;
}
.controls button:disabled{ opacity:.4; cursor:default; }

.panels{
  width:min(92vw,900px);
  margin:0 auto;
  display:grid;
  grid-template-columns:1fr;
  gap:10px;
}
@media (min-width: 900px){
  .panels{ grid-template-columns: 1fr 1fr; }
}

.card{
  border:1px solid #222;
  border-radius:12px;
  overflow:hidden;
  background:#0f1115;
}
.card .head{
  padding:10px 12px;
  background:#141820;
  border-bottom:1px solid #222;
  font-weight:600;
}
.card .body{ padding:12px; }

.moves{
  font-size:18px;
  line-height:2.1;
}

.move{
  display:inline-block;
  padding:2px 6px;
  border-radius:7px;
  cursor:pointer;
  user-select:none;
}
.move:hover{ background:#20263a; }
.move.active{ background:#3a7afe; color:#fff; }

.variation{
  margin:6px 0 10px 26px;
  padding-left:10px;
  border-left:2px dashed #444;
  opacity:.95;
}

.dragHint{
  display:inline-block;
  margin-left:6px;
  font-size:12px;
  opacity:.7;
  border:1px solid #222;
  padding:2px 6px;
  border-radius:999px;
}

.dropTarget{
  outline:2px dashed transparent;
  outline-offset:2px;
}
.dropTarget.dragover{
  outline-color:#3a7afe;
}

.commentRow{
  margin:4px 0 10px 18px;
  padding:6px 8px;
  border-left:3px solid #3a7afe;
  border-radius:8px;
  background:#121724;
  color:#cfd6ff;
  font-size:14px;
}

.inlineEditor{
  margin:6px 0 10px 18px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.inlineEditor textarea{
  width:100%;
  min-height:70px;
  resize:vertical;
  border-radius:10px;
  border:1px solid #222;
  background:#0f1115;
  color:#e6e6e6;
  padding:10px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size:14px;
}
.inlineEditor .row{
  display:flex;
  gap:8px;
}
.inlineEditor .row button{
  flex:1;
  padding:10px 0;
  border:none;
  border-radius:10px;
  background:#1f2430;
  color:#ddd;
  cursor:pointer;
}

.iconBtn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:28px;
  height:28px;
  border-radius:999px;
  border:none;
  background:#1f2430;
  color:#ddd;
  cursor:pointer;
  margin-left:6px;
}
.iconBtn:hover{ background:#2a3150; }

.pgnBox{
  width:100%;
  height:320px;
  resize:vertical;
  border-radius:12px;
  border:1px solid #222;
  background:#0f1115;
  color:#e6e6e6;
  padding:12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
  font-size:14px;
}

.pgnActions{
  display:flex;
  gap:8px;
  margin-top:10px;
}
.pgnActions button{
  flex:1;
  padding:10px 0;
  border:none;
  border-radius:10px;
  background:#1f2430;
  color:#ddd;
  cursor:pointer;
}
</style>
</head>

<body>

<div class="top">
  <img src="https://jekyllchess.github.io/assets/favicon.png" alt="">
  <div class="title">JekyllChess PGN App</div>
</div>

<div class="wrap">
  <div id="board"></div>

  <!-- Navigation (mainline only) -->
  <div class="controls">
    <button id="btnStart" title="Start">‚èÆ</button>
    <button id="btnPrev" title="Previous">‚óÄ</button>
    <button id="btnNext" title="Next">‚ñ∂</button>
    <button id="btnEnd" title="End">‚è≠</button>
  </div>

  <div class="panels">

    <div class="card">
      <div class="head">Moves</div>
      <div class="body">
        <div class="moves" id="moves"></div>
      </div>
    </div>

    <div class="card">
      <div class="head">PGN text editor</div>
      <div class="body">
        <textarea id="pgnText" class="pgnBox" spellcheck="false"></textarea>
        <div class="pgnActions">
          <button id="copyPGN">Copy PGN</button>
          <button id="copyFEN">Copy FEN</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
(() => {
  const FIG = { K:"‚ôî", Q:"‚ôï", R:"‚ôñ", B:"‚ôó", N:"‚ôò" };
  const figSAN = (s) => s.replace(/^[KQRBN]/, p => FIG[p] || p).replace(/=([QRBN])/g, (_,p)=>"="+(FIG[p]||p));

  // ---------------------------
  // PGN headers (basic valid STR)
  // ---------------------------
  function todayYYYYMMDD() {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}.${m}.${day}`;
  }
  let TAGS = {
    Event: "Casual Game",
    Site: "Local",
    Date: todayYYYYMMDD(),
    Round: "-",
    White: "White",
    Black: "Black",
    Result: "*"
  };
  function tagSection() {
    const order = ["Event","Site","Date","Round","White","Black","Result"];
    return order.map(k => `[${k} "${(TAGS[k] ?? "")}"]`).join("\n");
  }

  // ---------------------------
  // Move tree
  // Each node is a move (SAN), with:
  // - next: main continuation
  // - variations: alternative continuations (each is also a node)
  // - parent: previous move in that line (root is special)
  // ---------------------------
  let NODE_SEQ = 1;
  const byId = new Map();

  class Node {
    constructor(san=null, parent=null) {
      this.id = "n" + (NODE_SEQ++);
      this.san = san;               // null for root
      this.comment = "";            // comment AFTER this move
      this.parent = parent;         // previous move in this line (or root)
      this.next = null;             // main continuation
      this.variations = [];         // array of Node (variation roots)
      byId.set(this.id, this);
    }
  }

  const root = new Node(null, null);

  // Cursor = last move of the line we are currently on (for board-entry continuation/branching)
  let cursor = root;

  // Mainline navigation pointer (node along root.next chain, or null at start)
  let navNode = null; // a Node on mainline, or null

  // Current board position FEN (for Copy FEN)
  let currentFEN = "start";

  // ---------------------------
  // Chess instances
  // ---------------------------
  const chess = new Chess(); // represents CURRENT cursor line position on board

  const board = Chessboard("board", {
    position: "start",
    draggable: true,
    pieceTheme: "https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png",
    onDrop
  });

  function setBoard(fen, animate) {
    currentFEN = fen;
    board.position(fen, !!animate);
  }

  function rebuildChessToNode(target) {
    // Rebuild chess position by walking from node -> root via parent pointers
    chess.reset();
    if (!target) { setBoard("start", true); return; }
    const chain = [];
    let n = target;
    while (n && n !== root) { chain.push(n); n = n.parent; }
    chain.reverse();
    for (const mv of chain) chess.move(mv.san);
    setBoard(chess.fen(), true);
  }

  function rebuildChessToCursorNoAnim() {
    chess.reset();
    const chain = [];
    let n = cursor;
    while (n && n !== root) { chain.push(n); n = n.parent; }
    chain.reverse();
    for (const mv of chain) chess.move(mv.san);
    setBoard(chess.fen(), false); // user move entry should not animate
  }

  // ---------------------------
  // Variation promotion: drag a variation root onto the mainline move at same branch point
  // Rule: only allow promoting a *variation root* that is a direct child of the branch parent.
  // ---------------------------
  function promoteVariation(branchParentId, variationRootId) {
    const parent = byId.get(branchParentId);
    const vNode = byId.get(variationRootId);
    if (!parent || !vNode) return;

    const idx = parent.variations.findIndex(x => x.id === vNode.id);
    if (idx < 0) return; // not a direct variation of that parent

    const currentMain = parent.next;
    if (currentMain && currentMain.id === vNode.id) return; // already mainline

    // Remove vNode from variations
    parent.variations.splice(idx, 1);

    // Old main becomes a variation (if it exists)
    if (currentMain) {
      parent.variations.unshift(currentMain);
      currentMain.parent = parent;
    }

    // New mainline continuation
    parent.next = vNode;
    vNode.parent = parent;

    // If navigation node was the old main, keep it stable by id (it may now be a variation)
    // Cursor stays on same node id; we'll rebuild chess to cursor
    renderAll();
    rebuildChessToCursorNoAnim();
  }

  // ---------------------------
  // Inline comment editor
  // ---------------------------
  let openEditorForNodeId = null;

  function openCommentEditor(nodeId) {
    openEditorForNodeId = nodeId;
    renderAll();
  }

  function closeCommentEditor() {
    openEditorForNodeId = null;
    renderAll();
  }

  function saveComment(nodeId, text) {
    const n = byId.get(nodeId);
    if (!n || n === root) return;
    n.comment = (text || "").replace(/\}/g, "").trim();
    openEditorForNodeId = null;
    renderAll();
    syncPGN();
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  const movesDiv = document.getElementById("moves");
  const pgnText = document.getElementById("pgnText");

  function renderLine(startNode, container, ply, isMainline) {
    // Traverse along .next
    let prev = startNode;           // branch parent for the first node in this line
    let node = startNode.next;      // first move node
    let localPly = ply;

    while (node) {
      const span = document.createElement("span");
      span.className = "move dropTarget";
      span.textContent = ((localPly % 2 === 0) ? `${Math.floor(localPly/2)+1}. ` : "") + figSAN(node.san) + " ";
      span.dataset.nodeId = node.id;
      span.dataset.branchParentId = prev.id; // important: branch point is the previous node in that line

      // Click = navigate to that node (animate)
      span.onclick = () => {
        navNode = isOnMainline(node) ? node : navNode;
        cursor = node;
        rebuildChessToNode(node);
        highlightActive(node.id);
      };

      // Drop target for promotion (drop variation root here to promote at prev)
      span.ondragover = (e) => { e.preventDefault(); span.classList.add("dragover"); };
      span.ondragleave = () => span.classList.remove("dragover");
      span.ondrop = (e) => {
        e.preventDefault();
        span.classList.remove("dragover");
        const draggedId = e.dataTransfer.getData("text/nodeId");
        const branchParentId = span.dataset.branchParentId;
        promoteVariation(branchParentId, draggedId);
      };

      container.appendChild(span);

      // Inline comment button (for any node)
      const cbtn = document.createElement("button");
      cbtn.className = "iconBtn";
      cbtn.type = "button";
      cbtn.title = "Edit comment";
      cbtn.textContent = "üí¨";
      cbtn.onclick = () => openCommentEditor(node.id);
      container.appendChild(cbtn);

      // Comment display
      if (node.comment && node.comment.trim()) {
        const c = document.createElement("div");
        c.className = "commentRow";
        c.textContent = node.comment;
        container.appendChild(c);
      }

      // Inline editor under this move if open
      if (openEditorForNodeId === node.id) {
        const ed = document.createElement("div");
        ed.className = "inlineEditor";

        const ta = document.createElement("textarea");
        ta.value = node.comment || "";
        ed.appendChild(ta);

        const row = document.createElement("div");
        row.className = "row";

        const save = document.createElement("button");
        save.type = "button";
        save.textContent = "Save comment";
        save.onclick = () => saveComment(node.id, ta.value);

        const cancel = document.createElement("button");
        cancel.type = "button";
        cancel.textContent = "Cancel";
        cancel.onclick = () => closeCommentEditor();

        row.appendChild(save);
        row.appendChild(cancel);
        ed.appendChild(row);

        container.appendChild(ed);
      }

      // Render variations branching AFTER this move (nested variations supported)
      if (node.variations.length) {
        node.variations.forEach(vRoot => {
          const vDiv = document.createElement("div");
          vDiv.className = "variation";

          // Variation root move shown (draggable)
          const vSpan = document.createElement("span");
          vSpan.className = "move";
          vSpan.textContent = figSAN(vRoot.san) + " ";
          vSpan.dataset.nodeId = vRoot.id;

          // Make the variation root draggable for promotion
          vSpan.draggable = true;
          vSpan.ondragstart = (e) => {
            e.dataTransfer.setData("text/nodeId", vRoot.id);
            e.dataTransfer.effectAllowed = "move";
          };

          vSpan.onclick = () => {
            cursor = vRoot;
            rebuildChessToNode(vRoot);
            highlightActive(vRoot.id);
          };

          vDiv.appendChild(vSpan);

          const hint = document.createElement("span");
          hint.className = "dragHint";
          hint.textContent = "drag to promote";
          vDiv.appendChild(hint);

          // comment button for variation root
          const vCbtn = document.createElement("button");
          vCbtn.className = "iconBtn";
          vCbtn.type = "button";
          vCbtn.title = "Edit comment";
          vCbtn.textContent = "üí¨";
          vCbtn.onclick = () => openCommentEditor(vRoot.id);
          vDiv.appendChild(vCbtn);

          if (vRoot.comment && vRoot.comment.trim()) {
            const cc = document.createElement("div");
            cc.className = "commentRow";
            cc.textContent = vRoot.comment;
            vDiv.appendChild(cc);
          }
          if (openEditorForNodeId === vRoot.id) {
            const ed = document.createElement("div");
            ed.className = "inlineEditor";

            const ta = document.createElement("textarea");
            ta.value = vRoot.comment || "";
            ed.appendChild(ta);

            const row = document.createElement("div");
            row.className = "row";

            const save = document.createElement("button");
            save.type = "button";
            save.textContent = "Save comment";
            save.onclick = () => saveComment(vRoot.id, ta.value);

            const cancel = document.createElement("button");
            cancel.type = "button";
            cancel.textContent = "Cancel";
            cancel.onclick = () => closeCommentEditor();

            row.appendChild(save);
            row.appendChild(cancel);
            ed.appendChild(row);

            vDiv.appendChild(ed);
          }

          // Then render the remainder of that variation line using vRoot as "start"
          // (vRoot is itself the first move, so we render its .next continuation beneath)
          renderLine(vRoot, vDiv, localPly + 1, false);

          container.appendChild(vDiv);
        });
      }

      prev = node;
      node = node.next;
      localPly++;
    }
  }

  function isOnMainline(node) {
    // node is on mainline if reachable by following root.next chain
    let n = root.next;
    while (n) { if (n.id === node.id) return true; n = n.next; }
    return false;
  }

  function highlightActive(nodeId) {
    document.querySelectorAll(".move").forEach(el => el.classList.remove("active"));
    const el = document.querySelector(`.move[data-node-id="${nodeId}"]`);
    if (el) el.classList.add("active");
  }

  function renderAll() {
    movesDiv.innerHTML = "";
    renderLine(root, movesDiv, 0, true);

    // Add a "+" at end of current cursor move to add comment quickly (inline, not prompt)
    // (kept as a convenience; comment editing is inline now anyway)
    // Not necessary, but harmless: users can click üí¨ too.
  }

  // ---------------------------
  // PGN serialization (with nested variations + comments)
  // ---------------------------
  function serializeFrom(node, startPly, variationStart) {
    // node is the "previous" node; we serialize its .next chain
    let out = [];
    let ply = startPly;

    let cur = node.next;
    let first = true;

    while (cur) {
      const moveNo = Math.floor(ply/2) + 1;
      const isWhite = (ply % 2 === 0);

      if (first) {
        if (variationStart) {
          out.push(isWhite ? `${moveNo}.` : `${moveNo}...`);
        } else {
          if (isWhite) out.push(`${moveNo}.`);
        }
      } else {
        if (isWhite) out.push(`${moveNo}.`);
      }

      out.push(cur.san);

      if (cur.comment && cur.comment.trim()) {
        out.push(`{${cur.comment.replace(/\}/g,"")}}`);
      }

      // Variations after this move
      if (cur.variations.length) {
        cur.variations.forEach(v => {
          const vText = serializeVariation(v, ply + 1);
          out.push(vText);
        });
      }

      first = false;
      ply += 1;
      cur = cur.next;
    }

    return out.join(" ").trim();
  }

  function serializeVariation(variationRoot, startPly) {
    // variationRoot is the first move of that variation line
    // We need to serialize it as: (moveNo... SAN ... )
    const pseudoParent = { next: variationRoot }; // to reuse serializeFrom
    const text = serializeFrom(pseudoParent, startPly, true);
    return "(" + text + ")";
  }

  function syncPGN() {
    const movetext = serializeFrom(root, 0, false);
    const result = TAGS.Result || "*";
    const full = tagSection() + "\n\n" + (movetext ? (movetext + " " + result) : result);
    pgnText.value = full.trim() + "\n";
  }

  // ---------------------------
  // Move entry logic (no duplicates; nested variations supported)
  // ---------------------------
  function onDrop(from, to) {
    // DO NOT animate for user-entered moves
    const test = new Chess(chess.fen());
    const m = test.move({ from, to, promotion:"q" });
    if (!m) return "snapback";

    // Decide where to go from cursor:
    // - if cursor.next SAN matches => continue main continuation
    // - else if a variation root at cursor has same first SAN => enter/continue that variation
    // - else if cursor.next is empty => set cursor.next
    // - else create a NEW variation root (only if no existing with same first SAN)
    if (cursor.next && cursor.next.san === m.san) {
      cursor = cursor.next;
    } else {
      const existingVar = cursor.variations.find(v => v.san === m.san);
      if (existingVar) {
        cursor = existingVar;
      } else {
        const newNode = new Node(m.san, cursor);
        if (!cursor.next) {
          cursor.next = newNode;
        } else {
          cursor.variations.push(newNode);
        }
        cursor = newNode;
      }
    }

    // Apply move to chess (current line)
    chess.move(m.san);
    setBoard(chess.fen(), false);

    // Keep navNode sensible if we're on mainline
    if (isOnMainline(cursor)) navNode = cursor;

    renderAll();
    syncPGN();
    highlightActive(cursor.id);
    updateNavButtons();
  }

  // ---------------------------
  // Navigation (mainline) with animation
  // ---------------------------
  const btnStart = document.getElementById("btnStart");
  const btnPrev  = document.getElementById("btnPrev");
  const btnNext  = document.getElementById("btnNext");
  const btnEnd   = document.getElementById("btnEnd");

  function mainlineNodes() {
    const arr = [];
    let n = root.next;
    while (n) { arr.push(n); n = n.next; }
    return arr;
  }

  function updateNavButtons() {
    const arr = mainlineNodes();
    const hasMoves = arr.length > 0;
    [btnStart,btnPrev,btnNext,btnEnd].forEach(b => b.disabled = !hasMoves);
  }

  function goStart() {
    navNode = null;
    cursor = root;
    chess.reset();
    setBoard("start", true);
    highlightActive(""); // none
  }

  function goEnd() {
    const arr = mainlineNodes();
    if (!arr.length) return goStart();
    navNode = arr[arr.length - 1];
    cursor = navNode;
    rebuildChessToNode(navNode);
    highlightActive(navNode.id);
  }

  function goPrev() {
    const arr = mainlineNodes();
    if (!arr.length) return;
    if (!navNode) return;
    const idx = arr.findIndex(x => x.id === navNode.id);
    if (idx <= 0) {
      goStart();
      return;
    }
    navNode = arr[idx - 1];
    cursor = navNode;
    rebuildChessToNode(navNode);
    highlightActive(navNode.id);
  }

  function goNext() {
    const arr = mainlineNodes();
    if (!arr.length) return;
    if (!navNode) {
      navNode = arr[0];
    } else {
      const idx = arr.findIndex(x => x.id === navNode.id);
      navNode = arr[Math.min(arr.length - 1, idx + 1)];
    }
    cursor = navNode;
    rebuildChessToNode(navNode);
    highlightActive(navNode.id);
  }

  btnStart.onclick = goStart;
  btnPrev.onclick  = goPrev;
  btnNext.onclick  = goNext;
  btnEnd.onclick   = goEnd;

  document.addEventListener("keydown", (e) => {
    const active = document.activeElement;
    const typing = active && (active.tagName === "TEXTAREA" || active.tagName === "INPUT");
    if (typing) return;
    if (e.key === "Home") { e.preventDefault(); goStart(); }
    else if (e.key === "End") { e.preventDefault(); goEnd(); }
    else if (e.key === "ArrowLeft") { e.preventDefault(); goPrev(); }
    else if (e.key === "ArrowRight") { e.preventDefault(); goNext(); }
  });

  // ---------------------------
  // Copy buttons
  // ---------------------------
  function writeClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) return navigator.clipboard.writeText(text);
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
    return Promise.resolve();
  }

  document.getElementById("copyPGN").onclick = () => writeClipboard(pgnText.value);
  document.getElementById("copyFEN").onclick = () => writeClipboard(currentFEN);

  // ---------------------------
  // Initial
  // ---------------------------
  renderAll();
  syncPGN();
  updateNavButtons();
  setBoard("start", false);
  window.addEventListener("resize", () => board.resize());
})();
</script>

</body>
</html>