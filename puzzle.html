<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JekyllChess ‚Äì Puzzle Loader (Safe Version)</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Google Font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;700&display=swap" rel="stylesheet">

  <!-- Chessboard.js (CORRECT library) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css">

  <style>
    body {
      font-family: Raleway, Arial, sans-serif;
      padding: 20px;
    }
    #errorPanel {
      margin-top: 20px;
      padding: 10px;
      background: #ffecec;
      border: 1px solid #ff8c8c;
      border-radius: 6px;
      display: none;
      white-space: pre-wrap;
    }
    textarea {
      width: 450px;
      height: 150px;
    }
    #status {
      margin-top: 20px;
      font-size: 18px;
    }
    #puzzleNum {
      margin-top: 10px;
    }
  </style>
</head>

<body>

<h2>Chess Puzzle Loader (PGN + Markdown)</h2>

<!-- ============================== -->
<!-- INPUT: REMOTE PGN -->
<!-- ============================== -->
<h4>Load PGN from URL</h4>
<input id="pgnUrl" type="text" placeholder="https://example.com/puzzles.pgn" style="width: 450px;">
<button id="loadPgnBtn" class="btn btn-primary btn-sm">Load PGN</button>

<!-- ============================== -->
<!-- INPUT: MARKDOWN PUZZLES -->
<!-- ============================== -->
<h4 class="mt-4">Load Markdown Puzzle Blocks</h4>
<textarea id="mdInput" placeholder="<puzzle>FEN: ... Solution: ...</puzzle>"></textarea>
<br>
<button id="loadMdBtn" class="btn btn-secondary btn-sm mt-2">Load Markdown</button>

<hr>

<button id="nextBtn" class="btn btn-success btn-sm" disabled>Next Puzzle</button>

<div id="puzzleNum"></div>
<div id="board" style="width: 400px;"></div>
<div id="status"></div>

<!-- Validation + debug errors -->
<div id="errorPanel"></div>

<!-- ============================== -->
<!-- SCRIPTS -->
<!-- ============================== -->

<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

<script>
/* ============================================================
   1. SAN CLEANING AND VALIDATION UTILITIES
   ============================================================ */

function cleanSAN(san) {
  return san
    .replace(/^\d+\.+/, "")   // 1. or 1... or 23.
    .replace(/[!?]+/g, "")    // strip annotations ! ? !! !?
    .trim();
}

function isValidFEN(fen) {
  try {
    const g = new Chess(fen);
    return g.fen() === fen;
  } catch {
    return false;
  }
}

/* ============================================================
   2. SAFE PGN PARSER WITH VALIDATION
   ============================================================ */

function parsePGNPuzzles(pgnText) {
  const puzzles = [];
  const errors = [];

  // Split on blank line before [FEN]
  const blocks = pgnText.split(/\n\n(?=\[FEN)/g);

  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i].trim();
    if (!block) continue;

    const fenMatch = block.match(/\[FEN\s+"([^"]+)"\]/i);
    if (!fenMatch) {
      errors.push(`Puzzle ${i+1}: Missing FEN tag.`);
      continue;
    }

    const fen = fenMatch[1].trim();
    if (!isValidFEN(fen)) {
      errors.push(`Puzzle ${i+1}: Invalid FEN:\n${fen}`);
      continue;
    }

    let moves = [];

    const movesTag = block.match(/\[(Moves|Solution)\s+"([^"]+)"\]/i);
    if (movesTag) {
      moves = movesTag[2].trim().split(/\s+/);
    } else {
      // Extract from body
      const body = block.replace(/\[[^\]]+\]/g, "");
      moves = body
        .replace(/\d+\.+/g, " ")
        .replace(/[\?!]+/g, " ")
        .replace(/\{[^}]+\}/g, " ")
        .replace(/\s+/g, " ")
        .trim()
        .split(" ");
    }

    if (!moves.length) {
      errors.push(`Puzzle ${i+1}: No moves found.`);
      continue;
    }

    puzzles.push({ fen, moves });
  }

  return { puzzles, errors };
}

/* ============================================================
   3. MARKDOWN PARSER
   ============================================================ */

function parseMarkdownPuzzles(md) {
  const puzzles = [];
  const errors = [];

  const regex = /<puzzle>([\s\S]*?)<\/puzzle>/gi;
  let match;
  let counter = 0;

  while ((match = regex.exec(md)) !== null) {
    counter++;

    const block = match[1];
    const fenMatch = block.match(/FEN:\s*(.+)/i);
    const solMatch = block.match(/Solution:\s*(.+)/i);

    if (!fenMatch || !solMatch) {
      errors.push(`Puzzle ${counter}: Missing FEN or Solution.`);
      continue;
    }

    const fen = fenMatch[1].trim();
    if (!isValidFEN(fen)) {
      errors.push(`Puzzle ${counter}: Invalid FEN:\n${fen}`);
      continue;
    }

    const moves = solMatch[1].trim().split(/\s+/);
    if (!moves.length) {
      errors.push(`Puzzle ${counter}: No moves in Solution line.`);
      continue;
    }

    puzzles.push({ fen, moves });
  }

  if (!counter) {
    errors.push("No <puzzle> ... </puzzle> blocks found.");
  }

  return { puzzles, errors };
}

/* ============================================================
   4. DISPLAY ERRORS
   ============================================================ */

function showErrors(errors) {
  const panel = document.getElementById("errorPanel");
  if (!errors.length) {
    panel.style.display = "none";
    return;
  }
  panel.style.display = "block";
  panel.textContent = errors.join("\n\n");
}

/* ============================================================
   5. PUZZLE ENGINE
   ============================================================ */

let puzzles = [];
let puzzleUCI = [];
let currentPuzzleIndex = 0;
let step = 0;
let game = null;
let board = null;

function loadPuzzle(i) {
  const puzzle = puzzles[i];

  document.getElementById("puzzleNum").textContent =
    `Puzzle ${i+1} / ${puzzles.length}`;

  game = new Chess(puzzle.fen);

  puzzleUCI = [];

  let error = false;

  for (let san of puzzle.moves) {
    const cleaned = cleanSAN(san);
    if (!cleaned) continue;

    const moveObj = game.move(cleaned, { sloppy: true });
    if (!moveObj) {
      showErrors([`Invalid SAN in puzzle ${i+1}: ${san}`]);
      error = true;
      break;
    }

    puzzleUCI.push(moveObj.from + moveObj.to + (moveObj.promotion || ""));
    game.undo();
  }

  if (error) return;

  step = 0;
  board.position(puzzle.fen);
  document.getElementById("status").textContent = "Your move...";
  showErrors([]); // clear error panel
}

/* ============================================================
   6. CHESSBOARD EVENT HANDLERS
   ============================================================ */

function onDragStart(source, piece) {
  if (!game || game.game_over()) return false;
  if (game.turn() === "w" && piece.startsWith("b")) return false;
  if (game.turn() === "b" && piece.startsWith("w")) return false;
}

function onDrop(source, target) {
  const move = game.move({ from: source, to: target, promotion: "q" });

  if (!move) return "snapback";

  const userUCI = move.from + move.to + (move.promotion || "");
  const expectedUCI = puzzleUCI[step];

  if (userUCI !== expectedUCI) {
    document.getElementById("status").textContent = "‚ùå Wrong move";
    game.undo();
    return "snapback";
  }

  document.getElementById("status").textContent = "‚úÖ Correct!";
  step++;

  if (step < puzzleUCI.length) {
    const replySAN = puzzles[currentPuzzleIndex].moves[step];
    game.move(replySAN, { sloppy: true });
    step++;
    setTimeout(() => board.position(game.fen()), 250);
  }

  if (step >= puzzleUCI.length) {
    document.getElementById("status").textContent = "üéâ Puzzle solved!";
  }

  return true;
}

function onSnapEnd() {
  board.position(game.fen());
}

/* ============================================================
   7. INIT BOARD
   ============================================================ */

board = Chessboard("board", {
  draggable: true,
  position: "start",
  pieceTheme: "https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png",
  onDragStart,
  onDrop,
  onSnapEnd
});

/* ============================================================
   8. LOAD PGN FROM URL
   ============================================================ */

document.getElementById("loadPgnBtn").onclick = async () => {
  const url = document.getElementById("pgnUrl").value.trim();
  if (!url) return alert("Enter a PGN URL.");

  try {
    const text = await fetch(url).then(r => r.text());
    const { puzzles: P, errors } = parsePGNPuzzles(text);

    showErrors(errors);

    if (!P.length) return;

    puzzles = P;
    currentPuzzleIndex = 0;
    document.getElementById("nextBtn").disabled = false;
    loadPuzzle(0);
  } catch (err) {
    showErrors(["Failed to load PGN: " + err.message]);
  }
};

/* ============================================================
   9. LOAD MARKDOWN
   ============================================================ */

document.getElementById("loadMdBtn").onclick = () => {
  const md = document.getElementById("mdInput").value;
  const { puzzles: P, errors } = parseMarkdownPuzzles(md);

  showErrors(errors);
  if (!P.length) return;

  puzzles = P;
  currentPuzzleIndex = 0;
  document.getElementById("nextBtn").disabled = false;
  loadPuzzle(0);
};

/* ============================================================
   10. NEXT PUZZLE
   ============================================================ */

document.getElementById("nextBtn").onclick = () => {
  currentPuzzleIndex++;
  if (currentPuzzleIndex >= puzzles.length) currentPuzzleIndex = 0;
  loadPuzzle(currentPuzzleIndex);
};

</script>
</body>
</html>
